#!/usr/bin/env bash
set -euo pipefail

# 万一 zsh などで実行されても bash に切り替える
if [[ -z "${BASH_VERSION:-}" ]]; then
  exec /usr/bin/env bash "$0" "$@"
fi

usage() {
  cat <<'USAGE'
git-ai-msg: generate git commit subject line(s) from staged diff via OpenRouter.

Usage:
  git-ai-msg            # outputs 1 line
  git-ai-msg --n 3      # outputs 3 candidate lines

Env:
  OPENROUTER_API_KEY or OPENROUTER_API_KEY_FILE
  OPENROUTER_MODEL (default: google/gemini-3-flash-preview)
  AI_COMMIT_LANG (default: ja)
  AI_COMMIT_STYLE (default: conventional)  # conventional | plain
  AI_COMMIT_MAX_CHARS (default: 72)
  AI_COMMIT_MAX_BYTES (default: 120000)
  AI_COMMIT_EXCLUDE (optional): space-separated globs, e.g. ".env* secrets/* **/*.pem"
USAGE
}

N=1
while [[ $# -gt 0 ]]; do
  case "$1" in
    --n|-n)
      N="${2:-}"
      shift 2
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    *)
      echo "Unknown arg: $1" >&2
      usage >&2
      exit 2
      ;;
  esac
done

if ! [[ "$N" =~ ^[0-9]+$ ]] || (( N < 1 || N > 10 )); then
  echo "ERROR: --n must be 1..10" >&2
  exit 2
fi

MODEL="${OPENROUTER_MODEL:-google/gemini-3-flash-preview}"
LANG="${AI_COMMIT_LANG:-ja}"
STYLE="${AI_COMMIT_STYLE:-conventional}"   # conventional | plain
MAX_CHARS="${AI_COMMIT_MAX_CHARS:-72}"
MAX_BYTES="${AI_COMMIT_MAX_BYTES:-120000}"

# secrets: file-based
KEY_FILE="${OPENROUTER_API_KEY_FILE:-}"
if [[ -n "${OPENROUTER_API_KEY:-}" ]]; then
  API_KEY="$OPENROUTER_API_KEY"
elif [[ -n "$KEY_FILE" && -f "$KEY_FILE" ]]; then
  API_KEY="$(tr -d '\r\n' < "$KEY_FILE")"
else
  echo "ERROR: set OPENROUTER_API_KEY or OPENROUTER_API_KEY_FILE" >&2
  exit 1
fi
if [[ -z "$API_KEY" ]]; then
  echo "ERROR: OpenRouter API key is empty" >&2
  exit 1
fi

APP_REFERER="${OPENROUTER_HTTP_REFERER:-}"
APP_TITLE="${OPENROUTER_X_TITLE:-git-ai-commit}"

# staged check
if git diff --cached --quiet; then
  echo "ERROR: no staged changes (git add first)" >&2
  exit 2
fi

STATUS="$(git status --porcelain=v1 || true)"

# --- Security / Excludes ---
SECURITY_MODE="${AI_COMMIT_SECURITY:-block}"   # block | warn | off
REDACT_MODE="${AI_COMMIT_REDACT:-1}"           # 1: redact (warn時推奨), 0: no redact
EXCLUDE_CLEAR="${AI_COMMIT_EXCLUDE_CLEAR:-0}"  # 1: disable defaults

DEFAULT_EXCLUDE_PATTERNS=(
  ".env" ".env.*" ".envrc"
  "secrets/*" "**/secrets/*"
  ".ssh/*" "**/.ssh/*"
  "*.pem" "*.key" "*.p12" "*.pfx" "*.asc" "*.gpg"
  "id_rsa" "id_ed25519" "id_ecdsa" "id_dsa"
  "*.kdbx"
)

EXCLUDES=()

# デフォルト除外（必要なら AI_COMMIT_EXCLUDE_CLEAR=1 で無効化）
if [[ "$EXCLUDE_CLEAR" != "1" ]]; then
  for p in "${DEFAULT_EXCLUDE_PATTERNS[@]}"; do
    EXCLUDES+=(":(exclude)${p}")
  done
fi

# 追加除外（ユーザー指定）
if [[ -n "${AI_COMMIT_EXCLUDE:-}" ]]; then
  # shellcheck disable=SC2206
  PATTERNS=(${AI_COMMIT_EXCLUDE})
  for p in "${PATTERNS[@]}"; do
    EXCLUDES+=(":(exclude)${p}")
  done
fi


DIFF_CMD=(git diff --cached --no-color --minimal -- .)
if ((${#EXCLUDES[@]})); then
  DIFF_CMD+=("${EXCLUDES[@]}")
fi
DIFF_RAW="$("${DIFF_CMD[@]}" || true)"

# 機密検知 & マスク（OpenRouter 送信前）
if [[ "$SECURITY_MODE" != "off" ]]; then
  DIFF="$(
    python3 /dev/fd/3 "$SECURITY_MODE" "$REDACT_MODE" <<<"$DIFF_RAW" 3<<'PY'
import re, sys

mode = sys.argv[1]          # block|warn
redact = sys.argv[2] == "1"
text = sys.stdin.read()

# --- Patterns (high-signal) ---
BLOCK_PATTERNS = [
    (
        "private_key_block",
        re.compile(
            r"-----BEGIN [A-Z0-9 ]*PRIVATE KEY-----\s*\n"
            r"(?:[A-Za-z0-9+/=]{10,}\s*\n)+"
            r"-----END [A-Z0-9 ]*PRIVATE KEY-----",
            re.M,
        ),
    ),
    (
        "pgp_private_key",
        re.compile(
            r"-----BEGIN PGP PRIVATE KEY BLOCK-----\s*\n"
            r"(?:[A-Za-z0-9+/=]{10,}\s*\n)+"
            r"-----END PGP PRIVATE KEY BLOCK-----",
            re.M,
        ),
    ),
]

LINE_PATTERNS = [
    ("aws_access_key_id", re.compile(r"\b(AKIA[0-9A-Z]{16}|ASIA[0-9A-Z]{16})\b")),
    ("github_token",      re.compile(r"\b(ghp_[A-Za-z0-9]{20,}|github_pat_[A-Za-z0-9_]{20,})\b")),
    ("slack_token",       re.compile(r"\b(xox[baprs]-[A-Za-z0-9-]{10,})\b")),
    ("google_api_key",    re.compile(r"\b(AIzaSy[A-Za-z0-9_-]{20,})\b")),
    ("secret_assignment", re.compile(r"(?i)\b(password|passwd|secret|token|api[_-]?key|access[_-]?key)\b\s*[:=]\s*([^\s\"']{8,})")),
]

def mask(s: str) -> str:
    if len(s) <= 8:
        return "***"
    return s[:4] + "***" + s[-4:]

issues = []

# Detect block patterns
for name, pat in BLOCK_PATTERNS:
    if pat.search(text):
        issues.append((name, "<block>"))

# Track current file from diff headers for nicer reporting
cur_file = None
lines = text.splitlines()

for i, ln in enumerate(lines, 1):
    if ln.startswith("+++ b/"):
        cur_file = ln[6:].strip()
    for name, pat in LINE_PATTERNS:
        m = pat.search(ln)
        if not m:
            continue
        snippet = ln.strip()
        if len(snippet) > 160:
            snippet = snippet[:160] + "…"
        issues.append((name, f"{cur_file or '<unknown>'}:{i}: {snippet}"))

# If issues found, either block or warn
if issues:
    msg = ["[git-ai-msg] Potential secrets detected. Not sending diff to OpenRouter."]
    msg.append(f"[git-ai-msg] mode={mode} redact={redact}")
    for name, info in issues[:20]:
        msg.append(f"[git-ai-msg] - {name}: {info}")
    if len(issues) > 20:
        msg.append(f"[git-ai-msg] ... and {len(issues)-20} more")
    sys.stderr.write("\n".join(msg) + "\n")

    if mode == "block":
        sys.exit(42)

# Redaction (warn mode typically)
if redact:
    for name, pat in BLOCK_PATTERNS:
        text = pat.sub("[REDACTED_SECRET_BLOCK]", text)

    text = re.sub(r"\b(AKIA[0-9A-Z]{16}|ASIA[0-9A-Z]{16})\b", lambda m: mask(m.group(0)), text)
    text = re.sub(r"\b(ghp_[A-Za-z0-9]{20,}|github_pat_[A-Za-z0-9_]{20,})\b", lambda m: mask(m.group(0)), text)
    text = re.sub(r"\b(xox[baprs]-[A-Za-z0-9-]{10,})\b", lambda m: mask(m.group(0)), text)
    text = re.sub(r"\b(AIzaSy[A-Za-z0-9_-]{20,})\b", lambda m: mask(m.group(0)), text)

    def repl(m):
        key = m.group(1)
        val = m.group(2)
        return f"{key}={mask(val)}"
    text = re.sub(r"(?i)\b(password|passwd|secret|token|api[_-]?key|access[_-]?key)\b\s*[:=]\s*([^\s\"']{8,})", repl, text)

sys.stdout.write(text)
PY
  )"
else
  DIFF="$DIFF_RAW"
fi



INPUT="$(printf "## git status\n%s\n\n## git diff --cached\n%s\n" "$STATUS" "$DIFF" | head -c "$MAX_BYTES")"

if [[ "$STYLE" == "conventional" ]]; then
  FORMAT_HINT=$'Use Conventional Commits.\nAllowed types: feat, fix, docs, refactor, perf, test, build, ci, chore, revert.'
else
  FORMAT_HINT="Use a clear imperative subject."
fi

SYSTEM_PROMPT=$(
cat <<EOF
You write excellent git commit subjects.

Rules:
- Output EXACTLY ${N} candidates.
- Each candidate must be on its own line.
- Do NOT add numbering, bullets, quotes, or code fences.
- No trailing period.
- Prefer <= ${MAX_CHARS} characters (soft limit).
- Language: ${LANG}.
- ${FORMAT_HINT}
EOF
)

python3 - <<'PY' \
  "$API_KEY" "$MODEL" "$SYSTEM_PROMPT" "$INPUT" "$APP_REFERER" "$APP_TITLE" "$N"
import json, re, sys, urllib.request

api_key, model, system_prompt, user_input, http_referer, x_title, n_str = sys.argv[1:]
N = int(n_str)

url = "https://openrouter.ai/api/v1/chat/completions"
payload = {
    "model": model,
    "messages": [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_input},
    ],
    "temperature": 0.7 if N > 1 else 0.2,
    "max_tokens": 200,
}

headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
}
if http_referer:
    headers["HTTP-Referer"] = http_referer
if x_title:
    headers["X-Title"] = x_title

req = urllib.request.Request(url, data=json.dumps(payload).encode("utf-8"), headers=headers, method="POST")
with urllib.request.urlopen(req, timeout=30) as r:
    data = json.load(r)

txt = (data.get("choices") or [{}])[0].get("message", {}).get("content", "") or ""
lines = [ln.strip() for ln in txt.splitlines() if ln.strip()]

def normalize(s: str) -> str:
    s = s.strip().strip('"\'')

    # ありがちな番号/箇条書きを除去（モデルがルール違反した場合の保険）
    s = re.sub(r'^\s*[\-\*\u2022]\s*', '', s)
    s = re.sub(r'^\s*\(?\d+\)?[.)：:]\s*', '', s)
    s = re.sub(r'^\s*[A-Za-z]\)[.:]\s*', '', s)
    return s.strip()

cands = []
seen = set()
for ln in lines:
    ln = normalize(ln)
    if not ln:
        continue
    key = ln.lower()
    if key in seen:
        continue
    seen.add(key)
    cands.append(ln)
    if len(cands) >= N:
        break

if not cands:
    raise SystemExit("Empty message returned from model")

# もし不足したら、ある分だけ出す（上流でハンドリング）
for ln in cands:
    print(ln)
PY

